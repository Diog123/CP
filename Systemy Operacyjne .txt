----------------------------------------------------------------------------------------------------------------
LINKI:
YT: https://www.youtube.com/watch?v=cex9XrZCU14&list=PLfqABt5AS4FkW5mOn2Tn9ZZLLDwA3kZUY
[ 14:17 07.03.2025 ]
----------------------------------------------------------------------------------------------------------------
1. Obsługa błędów
  ~ errno to systemowa zmienna globalna, 
    ( lepiej używaj #include<errno.h> )
    która przechowuje kod błędu zwrócony 16:36 15.03.2025
    przez funkcje systemowe i biblioteczne

Informacje o kodach błedów oraz
odpowiadajacych im komunikatach można znaleźć w (man errno).

1.1 Funkcja biblioteczna 'perror'
  <stdio.h> 
  ~ automatycznie wypisuje komunikat błędu(errno) na stderr.	
     P1: Jak nie ma błedu to funkcja perror(""); -> "No error"
     P2: Jeśli otworzymy jakiś plik co nie istnieje perror(""); -> "No such file or directory"

1.2 Funkcja biblioteczna 'strerror'
  <string.h>
  Zwraca wskaźnik do statycznego łańcucha znaków zawierającego opis błędu
  // Zapisujemy wskaźnik do opisu błedu.
  char *error_message = strerror(errno);
  // Możemy go teraz wielokrotnie używać
  printf("Bład otwierania pliku %s\n", error_message);
  printf("Kod Błedu: %d, Opis: %s\n", errno, error_message); // W tym przypadku errno = 2.

1.3 Użyteczne makra języka C
 - __FILE__ -> zwraca nazwę pliku źródłowego (w formacie %s)
 - __LINE__ -> zwraca numer linii w tym pliku (w formacie %d) odnośnie miejsca ich wywołania.
 - __func__ -> zwraca nazwę funkcii (w formacie %s)
 Makra te są bardzo przydatne do debugowania, logowania błedów i diagnostyki w kodzie C! :)      <- -> Chat-gpt.

[ 14:51 07.03.2025 ]
----------------------------------------------------------------------------------------------------------------
2. Procesy

PROCES:  Proces reprezentuje program, który jest wykonywany, i ma przypisane zasoby systemowe. 
  Proces w systemie operacyjnym jest obiektem, który zarządza pamięcią, rejestrami, 
  otwartymi plikami, a także interakcjami z innymi procesami.

! -> UWAGA: Proces może wykonyważ co najwyżej jeden program, natomiast ten sam
program może być wykonywany w dowolnej liczbie procesów.

[ 16:36 15.03.2025 ]
2.1 Identyfikatory związane z procesami. 

Identyfikatory są wykorzystywane przez system operacyjny do śledzenia, kontrolowania i zarządzania procesami.
Identyfikatory te przyjmują wartości liczb całkowitych nieujemnych.

Pliki włączane <-> <sys/types.h>, <unistd.h>

UID(user id)            - uid_t getuid(void); 		- identyfikator użytkownika
GID(group id)           - gid_t getgid(void); 		- identyfikator grupy użytkownika.
PID(process id)         - pid_t getpid(void);           - identyfikator procesu.
PPID(parent process id) - pid_t getppid(void);          - identyfikator procesu macierzystego (przodka)
PGID(process group id)  - pid_t getpgid(pid_t pid);     - identyfikator grupy procesów ( = PID lidera grupy)
                        - pid_t getpgrp(void);          = getpgid(0); PGID procesy bieżącego
Spośród podanych funkcji jedynie getpgid może zakończyć się błędem - wówczas zwraca wartość -1 i ustawia zmienną errno.

! UWAGA: W przypadku gdy kompilator zgłasza ostrzeżenie przy wywołaniu którejś z powyższych (lub poniższych) funkcji, 
należy sprawdzić jej opis w man (...), i na początku pliku wstawić podane tam odpowiednie makro preprocesora. Makra te
dotyczą zwykle używanej wersji biblioteki glibc, którą najprościej można sprawdzić wykonując z poziomu powłoki (ldd --version).

Podstawowe informacje o bieżących procesach można uzyskać przy pomocy komendy ps. (man ps) -> dla więcej informacji.
W windowsie masz np. tasklist że działą podobnie.

Pliki włączane <-> <sys/types.h>, <unistd.h>
Prototyp           pid_t setpgid(pid_t pid, pid_t pgrp)
Sukces -> 0
Porżka -> -1 
Zmienia errno -> Tak

Funkcja setpgid służy do zmiany identyfikatora grupy procesów (PGID) danego procesu. Dzięki niej można tworzyć nowe
grupy procesów i organizować zarządzanie procesami. Funkcja ta może być skutecznie wywołana tylko kiedy wywołujący ją
proces ma odpowiednie uprawnienia, np. jest procesem macierzystym procesu docelowego.

[ 17:17 15.03.2025 ]
Tworzenie procesów potomnych - funkcja systemowa fork

Pliki włączane <-> <sys/types.h>, <unistd.h> (FOR LINUX)
Prototyp           pid_t fork(void);
Sukces  ->   [ 0 w procesie potomnym ], [PID procesu potomnego w procesie macierzystym ]
Porażka ->  -1
Zmienia errno -> Tak.

Funkcja systemowa fork tworzy proces potomny, który jest kopią procesu macierzystego(parent = macierzysty)
switch (fork())
{
  case -1:
    perror("fork error");
    exit(1);
  case 0:
    // akcja dla procesu potomnego ( czyli dla tego co my tworzymy ? )
    // tak teraz jesteśmy w nim bo tworzyliśmy 2 takie. (w dziecku )
  default:
    // akcja dla procesu macierzystego, np. wywolanie funkcji wait
};

A jakie są identyfikatory kiedy robimy: fork(); fork(); fork(); // czyli 8 - procesów.


